using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Text;

namespace Temporal.Internal;

public static class Guid64
{
    // Twitter Snowflake
    // -----------------
    // Twitter snowflake generates 64-bit unique IDs at high scale. 
    // It can create up to 4096 unique ID's per machine per millisecond in a cluster of up to 1024 machines.

    // The IDs generated by this service are roughly time sortable.
    // The IDs are made up of the following components:
    // Epoch timestamp in millisecond precision - 41 bits (gives us 69 years with a custom epoch)
    // Configured machine id - 10 bits(gives us up to 1024 machines)
    // Sequence number - 12 bits(A local counter per machine that rolls over every 4096)

    private const int TOTAL_BITS = 64;
    private const int EPOCH_BITS = 42;
    private const int NODE_ID_BITS = 10;
    private const int SEQUENCE_BITS = 12;

    private const int maxNodeId = (1 << NODE_ID_BITS) - 1;
    private const long maxSequence = (1 << SEQUENCE_BITS) - 1;

    // Custom Epoch (January 1, 2015 Midnight UTC = 2015-01-01T00:00:00Z)
    private const long CUSTOM_EPOCH = 1420070400000L;

    private static readonly long nodeId = CreateNodeId();

    private static long lastTimestamp = -1L;
    private static long sequence = 0L;

    [MethodImpl(MethodImplOptions.Synchronized)]
    public static long NextId()
    {
        var currentTimestamp = Timestamp();
        if (currentTimestamp < lastTimestamp)
            throw new InvalidOperationException("Invalid System Clock!");

        if (currentTimestamp == lastTimestamp)
        {
            sequence = sequence + 1 & maxSequence;
            if (sequence == 0)
            {
                // Sequence Exhausted, wait till next millisecond.
                currentTimestamp = WaitNextMillis(currentTimestamp);
            }
        }
        else
        {
            // reset sequence to start with zero for the next millisecond
            sequence = 0;
        }

        lastTimestamp = currentTimestamp;

        var id = currentTimestamp << TOTAL_BITS - EPOCH_BITS;
        id |= nodeId << TOTAL_BITS - EPOCH_BITS - NODE_ID_BITS;
        id |= sequence;
        return id;
    }

    // Get current timestamp in milliseconds, adjust for the custom epoch.
    private static long Timestamp()
        => DateTimeOffset.UtcNow.ToUnixTimeMilliseconds() - CUSTOM_EPOCH;

    // Block and wait till next millisecond. Called when sequence numbers are 
    // exhausted within a millisecond. I.e. we create more than 4096 IDs per millisecond.
    private static long WaitNextMillis(long currentTimestamp)
    {
        while (currentTimestamp == lastTimestamp)
        {
            currentTimestamp = Timestamp();
        }
        return currentTimestamp;
    }

    private static int CreateNodeId()
    {
        int nodeId;
        try
        {
            var sb = new StringBuilder();
            var networkInterfaces = NetworkInterface.GetAllNetworkInterfaces();
            foreach (var networkInterface in networkInterfaces)
            {
                var mac = networkInterface.GetPhysicalAddress().GetAddressBytes();
                if (mac != null)
                {
                    for (var i = 0; i < mac.Length; i++)
                    {
                        sb.Append(mac[i].ToString("X"));
                    }
                }
            }
            nodeId = MurmurHash.StringHash(sb.ToString());
        }
        catch
        {
            using var rng = new RNGCryptoServiceProvider();
            var rand = new byte[sizeof(int)];
            rng.GetBytes(rand);
            nodeId = BitConverter.ToInt32(rand, 0);
        }

        nodeId &= maxNodeId;
        return nodeId;
    }
}
